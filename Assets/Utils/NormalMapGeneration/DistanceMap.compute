#pragma kernel CSMain

// Input and output textures
Texture2D<float4> _sourceTex;
RWTexture2D<float4> _resultTex;

int _distance;

[numthreads(16, 16, 1)]
void CSMain (uint3 dispatchThreadID : SV_DispatchThreadID)
{
    uint2 texSize;
    _sourceTex.GetDimensions(texSize.x, texSize.y);

    if (dispatchThreadID.x >= texSize.x) return;
    if (dispatchThreadID.x < 0) return;
    if (dispatchThreadID.y >= texSize.y) return;
    if (dispatchThreadID.y < 0) return;


    int2 coords = uint2(dispatchThreadID.x, dispatchThreadID.y);
    if (_sourceTex[coords].a < 0.1)
    {
        _resultTex[coords] = float4(1, 1, 1, 1);
        return;
    }

    if (_distance < 0.1) _distance = 1;
    float minDistance = _distance * 100000;

    int minX = max(0, coords.x - _distance);
    int maxX = min(texSize.x, coords.x + _distance);
    int minY = max(0, coords.y - _distance);
    int maxY = min(texSize.y, coords.y + _distance);
    for (int yRect = minY; yRect <= maxY; yRect++)
    {
        for (int xRect = minX; xRect <= maxX; xRect++)
        {
            int2 currCoords = int2(xRect, yRect);

            // Found the edge
            if (_sourceTex[currCoords].a < 0.1)
            {
                float dist = distance(currCoords, coords);
                minDistance = min(minDistance, dist);
            }
        }
    }

    float divider = min(_distance, min(texSize.x/2, texSize.y/2));

    float heightValue = 1 - clamp(minDistance / divider, 0, 1);
    float4 heightColor = float4(heightValue, heightValue, heightValue, 1);

    _resultTex[coords] = heightColor;
}
