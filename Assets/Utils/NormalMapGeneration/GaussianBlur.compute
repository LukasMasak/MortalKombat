#pragma kernel CSMain

// Input and output textures
Texture2D<float4> _sourceTex;
RWTexture2D<float4> _resultTex;
Buffer<float> _gaussianKernel;

uint _blurRadius;

float3 LinearToSRGB(float3 linearCol)
{
    float3 srgbLo  = linearCol * 12.92;
    float3 srgbHi = 1.055 * pow(abs(linearCol), 1.0/2.4) - 0.055;
    float3 result = lerp(srgbLo, srgbHi, step(0.0031308, linearCol));
    return result;
}

[numthreads(16, 16, 1)]
void CSMain (uint3 dispatchThreadID : SV_DispatchThreadID)
{
    uint2 texSize;
    _sourceTex.GetDimensions(texSize.x, texSize.y);

    uint2 coords = dispatchThreadID.xy;
    if (coords.x >= texSize.x) return;
    if (coords.x < 0) return;
    if (coords.y >= texSize.y) return;
    if (coords.y < 0) return;

    if (_sourceTex[coords.xy].a < 0.1)
    {
        _resultTex[coords.xy] = float4(_sourceTex[coords.xy].rgb, 0);
        return;
    }

    float3 color = float3(0, 0, 0);
    float weightSum = 0.0;
    int kernelLineLength = _blurRadius + 1;

    // Calculate bounds
    int yMin = max(0, coords.y - _blurRadius);
    int yMax = min(texSize.y - 1, coords.y + _blurRadius);
    int xMin = max(0, coords.x - _blurRadius);
    int xMax = min(texSize.x - 1, coords.x + _blurRadius);

    // Sample neighbors and with Gaussian kernel weight
    for (int y = yMin; y <= yMax; y++)
    {
        for (int x = xMin; x <= xMax; x++)
        {
            int2 texCoord = int2(x, y);
            float4 sample = _sourceTex[texCoord];
            if (sample.w <= 0.1) continue;

            int offsetY = y - (coords.y - _blurRadius);
            int offsetX = x - (coords.x - _blurRadius);
            float weight = _gaussianKernel[offsetY * kernelLineLength + offsetX];

            color += sample.xyz * weight;
            weightSum += weight;
        }
    }
    color = color / weightSum;

    // Output the final pixel
    if (_sourceTex[coords].a <= 0.1) color = float3(0, 0, 0);
    color = LinearToSRGB(color);
    _resultTex[coords] = float4(color, _sourceTex[coords].w);
}
